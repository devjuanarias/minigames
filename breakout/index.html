<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Breakout de Bichigames</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  body {
    background-color: #000;
    color: #fff;
    font-family: 'Press Start 2P', sans-serif;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }
  #hud {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    z-index: 10;
    font-size: 16px;
  }
  #hud span {
    margin: 0 15px;
  }
  canvas {
    display: block;
    margin: 60px auto 0 auto;
    background-color: #000;
  }
</style>
</head>
<body>
<div id="hud">
  <span id="score">Puntaje: 0</span>
  <span id="level">Nivel: 1</span>
</div>
<canvas id="gameCanvas" width="640" height="480"></canvas>
<script>
(function() {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  let score = 0;
  let level = 1;
  const maxLevel = 10;
  let gameState = "playing";

  const brickConfig = {
    width: 75,
    height: 20,
    padding: 10,
    offsetTop: 30,
    offsetLeft: null
  };

  const paddle = {
    height: 10,
    width: 80,
    x: (canvas.width - 80) / 2,
    speed: 7,
    movingLeft: false,
    movingRight: false
  };

  const ball = {
    radius: 8,
    x: canvas.width / 2,
    y: canvas.height - 30,
    dx: 0,
    dy: 0,
    speed: 3
  };

  let bricks = [];
  let brickRowCount = 3;
  const brickColCount = 7;

  const brickColors = ["#e74c3c", "#f1c40f", "#2ecc71", "#3498db", "#9b59b6", "#e67e22", "#1abc9c", "#ecf0f1", "#e84393", "#2d3436"];

  function setupLevel() {
    brickRowCount = 3 + (level - 1);
    if (brickRowCount > brickColors.length) brickRowCount = brickColors.length;

    const totalBrickWidth = brickColCount * (brickConfig.width + brickConfig.padding) - brickConfig.padding;
    brickConfig.offsetLeft = (canvas.width - totalBrickWidth) / 2;

    bricks = [];
    for (let r = 0; r < brickRowCount; r++) {
      bricks[r] = [];
      for (let c = 0; c < brickColCount; c++) {
        const brickX = brickConfig.offsetLeft + c * (brickConfig.width + brickConfig.padding);
        const brickY = brickConfig.offsetTop + r * (brickConfig.height + brickConfig.padding);
        bricks[r][c] = { x: brickX, y: brickY, status: 1 };
      }
    }

    resetBall();
    paddle.x = (canvas.width - paddle.width) / 2;

    document.getElementById("score").textContent = "Puntaje: " + score;
    document.getElementById("level").textContent = "Nivel: " + level;

    gameState = "playing";
  }

  function resetBall() {
    ball.x = canvas.width / 2;
    ball.y = canvas.height - 30;
    ball.speed = level === 1 ? 3 : 2 + (level - 1) * 0.5;
    // Al iniciar la bola va hacia arriba, dirección horizontal 0 (centrado)
    ball.dx = 0;
    ball.dy = -ball.speed;
  }

  function drawBall() {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.closePath();
  }

  function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddle.x, canvas.height - paddle.height - 10, paddle.width, paddle.height);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.closePath();
  }

  function drawBricks() {
    for (let r = 0; r < brickRowCount; r++) {
      for (let c = 0; c < brickColCount; c++) {
        const b = bricks[r][c];
        if (b.status === 1) {
          ctx.beginPath();
          ctx.rect(b.x, b.y, brickConfig.width, brickConfig.height);
          ctx.fillStyle = brickColors[r % brickColors.length];
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  function collisionDetection() {
    for (let r = 0; r < brickRowCount; r++) {
      for (let c = 0; c < brickColCount; c++) {
        const b = bricks[r][c];
        if (b.status === 1) {
          if (
            ball.x > b.x &&
            ball.x < b.x + brickConfig.width &&
            ball.y - ball.radius < b.y + brickConfig.height &&
            ball.y + ball.radius > b.y
          ) {
            ball.dy = -ball.dy;
            b.status = 0;
            score += 10;
            document.getElementById("score").textContent = "Puntaje: " + score;
            if (isLevelCleared()) {
              gameState = "levelCompleted";
            }
          }
        }
      }
    }

    // Rebote en paredes verticales
    if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
      ball.dx = -ball.dx;
    }
    // Rebote en techo
    if (ball.y + ball.dy < ball.radius) {
      ball.dy = -ball.dy;
    }
    // Rebote en paddle
    else if (ball.y + ball.dy > canvas.height - ball.radius - paddle.height - 10) {
      if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
        // Calculamos dónde tocó respecto al centro del paddle
        const paddleCenter = paddle.x + paddle.width / 2;
        const distanceFromCenter = ball.x - paddleCenter;
        const normalizedDistance = distanceFromCenter / (paddle.width / 2); // -1 (izq) a 1 (der)
        const maxBounceAngle = Math.PI / 3; // 60 grados máximo

        const bounceAngle = normalizedDistance * maxBounceAngle;
        // Velocidad constante
        const speed = ball.speed;

        // Cambiamos dx y dy según ángulo de rebote
        ball.dx = speed * Math.sin(bounceAngle);
        ball.dy = -speed * Math.cos(bounceAngle);
      } else if (ball.y + ball.dy > canvas.height - ball.radius) {
        gameState = "gameOver";
      }
    }
  }

  function isLevelCleared() {
    for (let r = 0; r < brickRowCount; r++) {
      for (let c = 0; c < brickColCount; c++) {
        if (bricks[r][c].status === 1) return false;
      }
    }
    return true;
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBall();
    drawPaddle();
  }

  function update() {
    if (gameState === "playing") {
      if (paddle.movingRight && paddle.x < canvas.width - paddle.width) {
        paddle.x += paddle.speed;
      } else if (paddle.movingLeft && paddle.x > 0) {
        paddle.x -= paddle.speed;
      }
      ball.x += ball.dx;
      ball.y += ball.dy;
      collisionDetection();
    }

    draw();

    if (gameState === "playing") {
      requestAnimationFrame(update);
    } else if (gameState === "levelCompleted") {
      ctx.font = "20px 'Press Start 2P'";
      ctx.fillStyle = "#0f0";
      ctx.textAlign = "center";
      ctx.fillText("¡Nivel completado!", canvas.width / 2, canvas.height / 2 - 20);
      ctx.fillText("Presiona espacio para continuar", canvas.width / 2, canvas.height / 2 + 20);
    } else if (gameState === "gameOver") {
      ctx.font = "20px 'Press Start 2P'";
      ctx.fillStyle = "#f00";
      ctx.textAlign = "center";
      ctx.fillText("¡Juego terminado!", canvas.width / 2, canvas.height / 2 - 20);
      ctx.fillText("Presiona R para reiniciar", canvas.width / 2, canvas.height / 2 + 20);
    }
  }

  document.addEventListener("keydown", function(e) {
    if (e.code === "ArrowRight" || e.code === "KeyD") {
      paddle.movingRight = true;
    } else if (e.code === "ArrowLeft" || e.code === "KeyA") {
      paddle.movingLeft = true;
    } else if (e.code === "Space") {
      if (gameState === "levelCompleted") {
        if (level < maxLevel) {
          level++;
          setupLevel();
          update();
        } else {
          level = 1;
          score = 0;
          setupLevel();
          update();
        }
      }
    } else if (e.code === "KeyR") {
      if (gameState === "gameOver") {
        level = 1;
        score = 0;
        setupLevel();
        update();
      }
    }
  });

  document.addEventListener("keyup", function(e) {
    if (e.code === "ArrowRight" || e.code === "KeyD") {
      paddle.movingRight = false;
    } else if (e.code === "ArrowLeft" || e.code === "KeyA") {
      paddle.movingLeft = false;
    }
  });

  setupLevel();
  update();
})();
</script>
<footer>bichigames</footer>
</body>
</html>
