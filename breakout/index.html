<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Breakout de Bichigames</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  body {
    background-color: #000;
    color: #fff;
    font-family: 'Press Start 2P', sans-serif;
    margin: 0;
    padding: 0;
    overflow: hidden;
    user-select: none;
    touch-action: none; /* para evitar scroll en táctil */
  }
  #hud {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    z-index: 10;
    font-size: 16px;
  }
  #hud span {
    margin: 0 15px;
  }
  #record {
    position: absolute;
    top: 40px;
    width: 100%;
    text-align: center;
    z-index: 10;
    font-size: 14px;
    color: #0f0;
  }
  canvas {
    display: block;
    margin: 60px auto 0 auto;
    background-color: #000;
  }
  #overlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.85);
    color: #0f0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: 'Press Start 2P', sans-serif;
    font-size: 20px;
    z-index: 100;
    display: none;
  }
  #overlay button {
    margin-top: 20px;
    padding: 10px 25px;
    font-size: 16px;
    cursor: pointer;
    background: #0f0;
    border: none;
    border-radius: 6px;
    color: #000;
    font-weight: bold;
    transition: background-color 0.3s;
  }
  #overlay button:hover {
    background-color: #0c0;
  }
</style>
</head>
<body>
  <div id="hud">
    <span id="score">Puntaje: 0</span>
    <span id="level">Nivel: 1</span>
  </div>
  <div id="record">Récord: 0</div>
  <canvas id="gameCanvas" width="640" height="480"></canvas>

  <div id="overlay" role="dialog" aria-modal="true" aria-live="assertive">
    <div id="overlay-message"></div>
    <button id="overlay-btn">Reiniciar</button>
  </div>

<script>
(function() {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const recordEl = document.getElementById("record");
  const overlay = document.getElementById("overlay");
  const overlayMsg = document.getElementById("overlay-message");
  const overlayBtn = document.getElementById("overlay-btn");

  let score = 0;
  let level = 1;
  const maxLevel = 10;
  let gameState = "playing";

  const brickConfig = {
    width: 75,
    height: 20,
    padding: 10,
    offsetTop: 30,
    offsetLeft: null
  };

  const paddle = {
    height: 10,
    width: 80,
    x: (canvas.width - 80) / 2,
    speed: 7,
    movingLeft: false,
    movingRight: false
  };

  const ball = {
    radius: 8,
    x: canvas.width / 2,
    y: canvas.height - 30,
    dx: 0,
    dy: 0,
    speed: 3
  };

  let bricks = [];
  let brickRowCount = 3;
  const brickColCount = 7;

  const brickColors = ["#e74c3c", "#f1c40f", "#2ecc71", "#3498db", "#9b59b6", "#e67e22", "#1abc9c", "#ecf0f1", "#e84393", "#2d3436"];

  // Para efecto de destello cuando un ladrillo se rompe
  let flashBricks = [];

  // Sonidos simples con Web Audio API
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playSound(freq, duration=100) {
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = "square";
    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
    osc.start();
    osc.stop(audioCtx.currentTime + duration / 1000);
  }

  function setupLevel() {
    brickRowCount = 3 + (level - 1);
    if (brickRowCount > brickColors.length) brickRowCount = brickColors.length;

    const totalBrickWidth = brickColCount * (brickConfig.width + brickConfig.padding) - brickConfig.padding;
    brickConfig.offsetLeft = (canvas.width - totalBrickWidth) / 2;

    bricks = [];
    flashBricks = [];
    for (let r = 0; r < brickRowCount; r++) {
      bricks[r] = [];
      for (let c = 0; c < brickColCount; c++) {
        const brickX = brickConfig.offsetLeft + c * (brickConfig.width + brickConfig.padding);
        const brickY = brickConfig.offsetTop + r * (brickConfig.height + brickConfig.padding);
        bricks[r][c] = { x: brickX, y: brickY, status: 1 };
      }
    }

    resetBall();
    paddle.x = (canvas.width - paddle.width) / 2;

    scoreEl.textContent = "Puntaje: " + score;
    levelEl.textContent = "Nivel: " + level;
    updateRecord();

    gameState = "playing";
    overlay.style.display = "none";
  }

  function resetBall() {
    ball.x = canvas.width / 2;
    ball.y = canvas.height - 30;
    ball.speed = 3 + (level - 1) * 0.5; // velocidad que crece con nivel
    // Dirección aleatoria inicial horizontal, para no siempre ir recto arriba
    ball.dx = (Math.random() * 2 - 1) * ball.speed;
    ball.dy = -Math.sqrt(ball.speed*ball.speed - ball.dx*ball.dx);
  }

  function drawBall() {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.closePath();
  }

  function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddle.x, canvas.height - paddle.height - 10, paddle.width, paddle.height);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.closePath();
  }

  function drawBricks() {
    for (let r = 0; r < brickRowCount; r++) {
      for (let c = 0; c < brickColCount; c++) {
        const b = bricks[r][c];
        if (b.status === 1) {
          ctx.beginPath();
          ctx.rect(b.x, b.y, brickConfig.width, brickConfig.height);
          ctx.fillStyle = brickColors[r % brickColors.length];
          ctx.fill();
          ctx.closePath();
        }
      }
    }
    // Efecto flash para ladrillos rotos
    flashBricks = flashBricks.filter(flash => {
      flash.duration--;
      if (flash.duration <= 0) return false;
      ctx.beginPath();
      ctx.rect(flash.x, flash.y, brickConfig.width, brickConfig.height);
      ctx.fillStyle = `rgba(255,255,255,${flash.duration / 10})`;
      ctx.fill();
      ctx.closePath();
      return true;
    });
  }

  function collisionDetection() {
    for (let r = 0; r < brickRowCount; r++) {
      for (let c = 0; c < brickColCount; c++) {
        const b = bricks[r][c];
        if (b.status === 1) {
          if (
            ball.x > b.x &&
            ball.x < b.x + brickConfig.width &&
            ball.y - ball.radius < b.y + brickConfig.height &&
            ball.y + ball.radius > b.y
          ) {
            ball.dy = -ball.dy;
            b.status = 0;
            score += 10;
            scoreEl.textContent = "Puntaje: " + score;
            playSound(600, 80);
            if (score > getRecord()) saveRecord(score);
            flashBricks.push({ x: b.x, y: b.y, duration: 10 });
            if (isLevelCleared()) {
              gameState = "levelCompleted";
              showOverlay("¡Nivel completado!", "Continuar", () => {
                if (level < maxLevel) {
                  level++;
                } else {
                  level = 1;
                  score = 0;
                }
                setupLevel();
                update();
              });
              playSound(900, 200);
            }
          }
        }
      }
    }

    // Rebote en paredes verticales
    if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
      ball.dx = -ball.dx;
      playSound(400, 60);
    }
    // Rebote en techo
    if (ball.y + ball.dy < ball.radius) {
      ball.dy = -ball.dy;
      playSound(400, 60);
    }
    // Rebote en paddle
    else if (ball.y + ball.dy > canvas.height - ball.radius - paddle.height - 10) {
      if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
        const paddleCenter = paddle.x + paddle.width / 2;
        const distanceFromCenter = ball.x - paddleCenter;
        const normalizedDistance = distanceFromCenter / (paddle.width / 2);
        const maxBounceAngle = Math.PI / 3;

        const bounceAngle = normalizedDistance * maxBounceAngle;
        const speed = ball.speed;

        ball.dx = speed * Math.sin(bounceAngle);
        ball.dy = -speed * Math.cos(bounceAngle);

        playSound(700, 80);
      } else if (ball.y + ball.dy > canvas.height - ball.radius) {
        gameState = "gameOver";
        showOverlay("¡Juego terminado!", "Reiniciar", () => {
          level = 1;
          score = 0;
          setupLevel();
          update();
        });
        playSound(300, 500);
      }
    }
  }

  function isLevelCleared() {
    for (let r = 0; r < brickRowCount; r++) {
      for (let c = 0; c < brickColCount; c++) {
        if (bricks[r][c].status === 1) return false;
      }
    }
    return true;
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBall();
    drawPaddle();
  }

  function update() {
    if (gameState === "playing") {
      if (paddle.movingRight && paddle.x < canvas.width - paddle.width) {
        paddle.x += paddle.speed;
      } else if (paddle.movingLeft && paddle.x > 0) {
        paddle.x -= paddle.speed;
      }
      ball.x += ball.dx;
      ball.y += ball.dy;
      collisionDetection();
    }
    draw();
    if (gameState === "playing") {
      requestAnimationFrame(update);
    }
  }

  // Manejo de teclado
  document.addEventListener("keydown", function(e) {
    if (e.code === "ArrowRight" || e.code === "KeyD") {
      paddle.movingRight = true;
    } else if (e.code === "ArrowLeft" || e.code === "KeyA") {
      paddle.movingLeft = true;
    }
  });

  document.addEventListener("keyup", function(e) {
    if (e.code === "ArrowRight" || e.code === "KeyD") {
      paddle.movingRight = false;
    } else if (e.code === "ArrowLeft" || e.code === "KeyA") {
      paddle.movingLeft = false;
    }
  });

  // Manejo con ratón (mover paddle horizontalmente)
  canvas.addEventListener("mousemove", e => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    paddle.x = mouseX - paddle.width / 2;
    if (paddle.x < 0) paddle.x = 0;
    if (paddle.x > canvas.width - paddle.width) paddle.x = canvas.width - paddle.width;
  });

  // Manejo táctil
  canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touchX = e.touches[0].clientX - rect.left;
    paddle.x = touchX - paddle.width / 2;
    if (paddle.x < 0) paddle.x = 0;
    if (paddle.x > canvas.width - paddle.width) paddle.x = canvas.width - paddle.width;
  }, { passive: false });

  // Overlay
  function showOverlay(message, buttonText, callback) {
    overlayMsg.textContent = message;
    overlayBtn.textContent = buttonText;
    overlay.style.display = "flex";
    overlayBtn.onclick = () => {
      overlay.style.display = "none";
      callback();
    };
  }

  // LocalStorage récord
  function getRecord() {
    return parseInt(localStorage.getItem("breakoutRecord")) || 0;
  }
  function saveRecord(newRecord) {
    localStorage.setItem("breakoutRecord", newRecord);
    updateRecord();
  }
  function updateRecord() {
    recordEl.textContent = "Récord: " + getRecord();
  }

  setupLevel();
  update();

})();
</script>
<footer>bichigames</footer>
</body>
</html>
